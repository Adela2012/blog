# 服务端渲染的理解以及使⽤场景

## 理解

### 传统web开发
⽹⻚内容在服务端渲染完成，⼀次性传输到浏览器。客户端访问URL，服务器查询数据库，拼接HTML字符串，客户端收到响应，渲染html。浏览器拿到的是全部的DOM结构。

- 缺点：
    - 开发不友好。
    - 前后端不分离。
- 优点：
    - SEO友好。
    - 首屏速度快。

### 单页面应用（SPA）
页面内容由客户端JS渲染出来。客户端访问URL，服务器返回HTML文件，客户端渲染，生成 DOM 和操作 DOM。浏览器拿到的仅是简单宿主元素#app，没有内容。

- 缺点：
    - SEO不友好。通过 Ajax 获取内容，搜索引擎爬虫抓取工具并不会等待异步完成后再行抓取页面内容。
    - 首屏加载速度慢。需等待所有的 JavaScript 都完成下载并执行。
- 优点：
    - 渲染计算放到客户端。
    - 流量、带宽占用小。

### 服务器端渲染 (SSR)
服务器端渲染方案保留了上述两者的优点。服务器渲染出完整的⾸屏的dom结构返回，客户端拿到的内容包括⾸屏及完整spa结构，应⽤激活后依然按照spa⽅式运⾏。在同构开发中，我们依然使⽤webpack打包，解决了两个问题：服务端⾸屏渲染和客户端激活。方法是⽣成⼀个「服务器 bundle」⽤于服务端⾸屏渲染，和⼀个「客户端bundle」⽤于客户端激活。


#### 实现原理(vue-ssr)

1. app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。
1. webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。
1. 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 
BundleRenderer，然后生成 html 发送给客户端。
1. 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端。


#### 优缺点

- 缺点：
    - 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。
    - 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。
    - 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源。因此如果你预料在高流量环境 (high traffic) 下使用，需准备相应的服务器负载，并明智地采用缓存策略。
- 优点：
    - 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。
    - 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。




## 场景：

#### 改善少数营销页面SEO —— 预渲染
改善少数营销页面（例如 /, /about, /contact 等）的 SEO，可以使用预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。

#### 开箱即用解决方案 —— Nuxt.js
建立在同等的 Vue 技术栈之上，但抽象出很多模板，并提供了一些额外的功能。如果是全新开发一个SSR应用，使用Nuxt.js将会非常顺滑。但是这个方案并不适合控制应用程序的结构，因为nuxt的结构都已经限定了。

#### 后端自身集成 SSR 
使用 Node.js server 的服务器端单页面应用程序渲染。将 Vue 服务器端渲染 (SSR) 与其他后端设置进行混合使用。

