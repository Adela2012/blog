- 大华一共进行了三面。
- 一面是技术面。
- 二面是项目面。
- 三面是HR面。
- 现在把我记得的问题总结一下吧。

## 笔试
1. for in 和 for of区别。
2. 冒泡排序。
3. IE盒模型和标准模型的区别。
4. 一行代码搞定数组去重。

#### 1. for in 和 for of区别。
- for in遍历数组和对象的`索引`
- for of遍历数组的`元素值`

>  for in遍历数组和对象
```javascript
var arr = [1,2,3]
arr.name = 'name'
Array.prototype.method = function () {}
for (let i in arr) console.log(i+1)
// 01 11 21 name1 method1

var obj = {name: 'name'}
Object.prototype.method = function () {}
for (let i in obj) console.log(i+1)
// name1 method1
```
从上述代码打印出来的问题，我们可以得到1.3结论
1. 索引是字符串型的数字，因而不能直接进行几何运算
2. 遍历顺序可能不是实际的内部顺序
3. 遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性

for in 可以遍历到对象的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性
```javascript
var arr = [1,2,3]
arr.name = 'name'
Array.prototype.method = function () {}
for (let i in arr) if(arr.hasOwnProperty(i)) console.log(i+1)
// 01 11 21 name1

var obj = {name: 'name'}
Object.prototype.method = function () {}
for (let i in obj) if(Object.hasOwnProperty(i))  console.log(i+1)
// name1
```

>  for of遍历数组和对象
```javascript
var arr = [1,2,3]
arr.name = 'name'
Array.prototype.method = function () {}
for (let i of arr) console.log(i+1)
// 2 3 4

var obj = {name: 'name'}
Object.prototype.method = function () {}
for (let i of obj) console.log(i+1)
// VM1718:9 Uncaught TypeError: obj is not iterable at <anonymous>:9:15
```
从上述代码打印出来, 我们可以看到for of可以遍历数组，但是遍历对象报错。

总结： 
- for in 遍历数组和对象的索引，包括原型方法和属性。
- for of 遍历数组的元素值，不能遍历对象。



#### 2. 冒泡排序
```javascript
function bubble (array) {
  if (!Array.isArray(array)) throw new Error('unexpected parameter, should be array.') 
  let len = array.length
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      if (array[j] > array[j + 1]) {
        let tmp = array[j+1]
        array[j+1] = array[j]
        array[j] = tmp
      }
    }
  }
  return array
}
bubble([1,2,5,6,7,3,2,4,5,6,8,0,9])
```
复杂度分析：
- Time Complexity: O(n^2) average. best case: O(n). worst case: O(n^2)
- Space Complexity: O(1).
- 稳定

#### 3. IE盒模型和标准模型的区别。
- 分类：标准模型（content）、IE模型(border)
- 区别：不同点在于高度和宽度的不同。
- 设置：使用box-sizing: content-box/border-box


#### 4. 一行代码搞定数组去重。
```javascript
[...new Set([1,2,3,3])]
```

## 一面
1. 圣杯布局和双飞翼布局
2. flex 弹性盒布局
3. cookie/localStorage/sessionStorage/indexDB差别
4. vuex的模块。modules中namespaced的使用。
5. sass的使用。
6. 数组有哪些方法，map的使用。
7. 路由跳转。
8. echart使用。
9. webpack.
10. 设计模式

#### 1. 圣杯布局和双飞翼布局
- 两侧宽度固定，中间宽度自适应的三栏布局
- 中间部分在DOM结构上优先，以便先行渲染
- 允许三列中的任意一列成为最高列
- 只需要使用一个额外的`<div>`标签
> 圣杯布局
```html
<body>
  <style>
    body{
      min-width: 550px;
    }
    .container {
      padding-left:  150px;
      padding-right:  200px;
    }
    .center{
      float: left;
      width: 100%;
    }
    .left {
      float: left;
      width: 150px;
      margin-left: -100%;
      position: relative;
      right: 150px; 
    }
    .right {
      float: left;
      width: 200px;
      margin-right: -100%;
    }
  </style>
  <div class="header">header</div>
  <div class="container">
    <div class="center">center</div>
    <div class="left">left</div>
    <div class="right">right</div>
  </div>
  <div class="footer">footer</div>
</body>
```
> 双飞翼布局
```html
<style>
    body{
      min-width: 500px;
    }
    .container {
      width: 100%;
      float: left;
    }
    .center{
      margin-left: 150px;
      margin-right: 200px;
    }
    .left {
      float: left;
      width: 150px;
      margin-left: -100%;
    }
    .right {
      float: left;
      width: 200px;
      margin-left: -200px;
    }
</style>
<div class="header">header</div>
<div class="container">
  <div class="center">center</div>
</div>
<div class="left">left</div>
<div class="right">right</div>
<div class="footer">footer</div>
```
> 使用flex
```html
<style>
    .flex .container {
      display: flex;
    }
    .flex  .center{
      flex: 1;
    }
    .flex  .left {
      order: -1;
      flex: 0 0 150px;
    }
    .flex  .right {
      flex: 0 0 200px;
    }
</style>
<div class="header">header</div>
<div class="container">
  <div class="center">center</div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>
<div class="footer">footer</div>
```


#### 2. flex 弹性盒布局
![flex1](./images/flex1.png)
![flex2](./images/flex2.png)
将图片1写成图片2
```html
  <style>
    .container{
      width: 400px;
      height: 400px;
      border: 1px solid #333;
    }
    .box{
      width: 100px;
      height: 100px;
      background: blue;
    }
    .box:nth-child(2){
      background: red;
    }
    .box:nth-child(3){
      background: yellow;
    }
  </style>
  <div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
  </div>
```
在上述HTML代码上加上
```css
.container{
    display: flex;
    align-items: flex-end;
    flex-direction: row-reverse;
}
```

#### 3. 存储功能: cookie/localStorage/sessionStorage/indexDB

|     特性     |               cookie                |     localStorage     | sessionStorage |      indexDB       |
| :---------: | :---------------------------------: | :------------------: | :------------: | :-----------------: |
| 数据生命周期 |     一般由服务器生成，可以设置过期时间     | 除非被清理，否则一直存在 |  页面关闭就清理  | 除非被清理，否则一直存在 |
| 数据存储大小 |                  4K                  |          5M          |       5M       |         无限         |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 |        不参与         |      不参与     |        不参与        |

从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于 `cookie` 来说，我们还需要注意安全性。

|   属性    |                         作用                         |
| :-------: | :-------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |          不能通过 JS 访问 Cookie，减少 XSS 攻击         |
|  secure   |            只能在协议为 HTTPS 的请求中携带              |
| same-site |   规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击    |


> 补充：Service Worker
Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 **HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 `install` 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：

```js
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register('sw.js')
    .then(function(registration) {
      console.log('service worker 注册成功')
    })
    .catch(function(err) {
      console.log('servcie worker 注册失败')
    })
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener('install', e => {
  e.waitUntil(
    caches.open('my-cache').then(function(cache) {
      return cache.addAll(['./index.html', './index.js'])
    })
  )
})

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response
      }
      console.log('fetch source')
    })
  )
})
```
- 打开页面，可以在开发者工具中的 `Application` 看到 Service Worker 已经启动了
- 在 Cache 中也可以发现我们所需的文件已被缓存
- 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的

#### 4. vuex的模块。modules中namespaced的使用。
- vuex的模块
  - state => 基本数据 
  - getters => 从基本数据派生的数据 
  - mutations => 提交更改数据的方法，同步！ 
  - actions => 像一个装饰器，包裹mutations，使之可以异步。 
  - modules => 模块化Vuex

- namespaced: 为了解决不同模块命名冲突的问题，将不同模块的namespaced:true，之后在不同页面中引入getter、actions、mutations时，需要加上所属的模块名

#### 5. css预处理器的使用。sass/less。
CSS预处理器的原理: 是将类 CSS 语言通过 Webpack 编译 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能
1. 变量使用
2. 嵌套
3. 标识符&
4. 群组嵌套
5. 混合器
6. 继承
混合器会导致属性重复，css体积大，继承只继承css规则，不继承重复属性
https://www.sass.hk/guide/

- 混合器：实现大段样式的重用。通过@include包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则
```scss
$--sm: 1190px !default;

$--breakpoints: (
  'xs' : (max-width: $--sm),
  'sm' : (min-width: $--sm + 1px)
  // 'md' : (min-width: $--md),
  // 'lg' : (min-width: $--lg)
);

 @mixin res($key: 'sm', $map: $--breakpoints) {
	// 循环断点Map，如果存在则返回
	@if map-has-key($map, $key) {
		@media only screen and #{inspect(map-get($map, $key))} {
			@content;
		}
	} @else {
		@warn "Undefeined points: `#{$map}`";
	}
}

@include res(sm) {
  [class*="xs_"] {
    display: none
  }
}
```
- 继承
```scss
//通过选择器继承继承样式
.error {
  border: 1px solid red;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

#### 6. 数组有哪些方法。
- forEach
- map
- filter
- ...解构
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array

#### 7. 路由跳转。
1. 使用`<router-link></router-link>`标签实现跳转。如果希望跳转后，不保留上一个页面的历史记录，可以在router-lick上加入replace。`<router-link to="/"  replace></router-link>`
2. this.$router.push() 跳转
  - params: `this.$router.push({path:"/", params:{id:1}})`
  - query: `this.$router.push({path:"/", query:{id:1}})`
3. 返回上一页，不存在历史记录 `this.$router.replace({path:"/"})`

#### 8. echart使用。

#### 9. webpack。

#### 10. 设计模式

## 二面
项目流程
遇到的问题

## 三面
职业规划
领导对我的要求

